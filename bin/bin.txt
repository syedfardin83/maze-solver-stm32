
            // finally add the starting cell
            maze->path[maze->plen][0] = maze->curr_cell[0];
            maze->path[maze->plen][1] = maze->curr_cell[1];
            maze->plen++;

            // maze->path currently: [target, ..., start] -> reverse to [start, ..., target]
            for (int8_t i = 0; i < maze->plen / 2; i++)
            {
                int tx0 = maze->path[i][0];
                int ty0 = maze->path[i][1];
                maze->path[i][0] = maze->path[maze->plen - 1 - i][0];
                maze->path[i][1] = maze->path[maze->plen - 1 - i][1];
                maze->path[maze->plen - 1 - i][0] = tx0;
                maze->path[maze->plen - 1 - i][1] = ty0;
            }

            // follow maze->path from current -> intersection
            for (int8_t i = 1; i < maze->plen; i++)
            {
                int8_t sx = maze->path[i - 1][0];
                int8_t sy = maze->path[i - 1][1];
                int8_t dx = maze->path[i][0];
                int8_t dy = maze->path[i][1];

                // determine required absolute direction
                char need = 'N';
                if (dx == sx && dy == sy + 1)
                    need = 'N';
                else if (dx == sx + 1 && dy == sy)
                    need = 'E';
                else if (dx == sx && dy == sy - 1)
                    need = 'S';
                else if (dx == sx - 1 && dy == sy)
                    need = 'W';

                // verify that planned step is not blocked by a wall in the map
                int8_t blocked = 0;
                if (need == 'N' && maze->cells[sx][sy].wallFront)
                    blocked = 1;
                if (need == 'E' && maze->cells[sx][sy].wallRight)
                    blocked = 1;
                if (need == 'S' && maze->cells[sx][sy].wallBack)
                    blocked = 1;
                if (need == 'W' && maze->cells[sx][sy].wallLeft)
                    blocked = 1;
                if (blocked==1)
                {
                    // cleanup and abort
                    for (int8_t ii = 0; ii < maze_x_len; ii++)
                        for (int8_t jj = 0; jj < maze_y_len; jj++)
                            maze->cells[ii][jj].bfs_visited = 0;
                    maze->q_f = -1;
                    maze->q_r = -1;
                    return;
                }

                // turn to required direction using minimal turns
                if (maze->orient == need)
                {
                    // nothing
                }
                else if ((maze->orient == 'N' && need == 'S') || (maze->orient == 'S' && need == 'N') ||
                         (maze->orient == 'E' && need == 'W') || (maze->orient == 'W' && need == 'E'))
                {
                    turn_left(maze,sim_maze);
                    turn_left(maze,sim_maze);
                }
                else if ((maze->orient == 'N' && need == 'W') || (maze->orient == 'W' && need == 'S') ||
                         (maze->orient == 'S' && need == 'E') || (maze->orient == 'E' && need == 'N'))
                {
                    turn_left(maze,sim_maze);
                }
                else
                {
                    turn_right(maze,sim_maze);
                }

                // move forward one step
                move_forward(maze,sim_maze);
            }
